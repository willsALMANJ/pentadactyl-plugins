"use strict";
var INFO =
["plugin", { name: "brief",
             version: "1.0.0",
             href: "https://github.com/willsALMANJ/pentadactyl-plugins",
             summary: "Brief navigation and key mappings",
             xmlns: "dactyl" },
    ["author", { href: "https://github.com/willsALMANJ" },
        "Will Shanks"],
    ["license", { href: "http://www.mozilla.org/MPL/2.0/" },
        "Mozilla Public License 2.0"],
    ["project", { name: "Pentadactyl", "min-version": "1.0" }],
    ["p", {},
        "This plugin implements a command set for working ",
        "with the Brief RSS Reader add-on in Pentadactyl."]];
// More added to INFO below.

var briefURL = 'chrome://brief/content/brief.xul';
// Restrict :brief commands to briefURL
commands.execute(":group plugin-brief -n "+
	"-desc='group generated by brief.js plugin' -locs " + briefURL);
// Previous command restricts all group methods to briefURL.
// Have to use commands.execute to create a command that works elsewhere
commands.execute(":command! briefopen -n -desc 'Open Brief RSS reader' " +
	"-js Brief.open()");

//Needed for scope to load Brief's Storage resource with naming conflict
var localNS = new Object(); 

group.options.add(["brief-load-passkeys"],
    "Load default Brief passkeys when Brief plugin is loaded",
    "string", true,
    {
    	completer: function(args,context) {return [['true', 'true'],['false','false']]},
    	setter: loadPasskeys
     });

var defaultPasskeys="jkh<Enter>";

function loadPasskeys(values) {
	let passOpt=options.get('brief-load-passkeys');
	
	setPasskeys(passOpt.value=='true');
	
	return values
}
loadPasskeys();

function setPasskeys(addPasskeys) {
	if (typeof defaultPasskeys=='undefined') {
		return
	}

	var briefPasskeys = "'"+briefURL+"':"+defaultPasskeys;
	let passkeys=options.get('passkeys');
	let passkeysLoc=passkeys.value.toString().search(briefPasskeys);
	if (addPasskeys) {
		if (passkeysLoc==-1) {
			let newPasskeys=[passkeys.value.toString(),briefPasskeys].join(',');
			commands.execute(":set passkeys="+newPasskeys);
		}
	} else {
		if (passkeysLoc!=-1) {
			let passkeysArr=passkeys.value.toString().split(',');
			let briefIndex=passkeysArr.indexOf(briefPasskeys);
			let newPasskeysArr=[];
			for (let idx=0;idx<passkeysArr.length;idx++) {
				if (idx!=briefIndex) {
					newPasskeysArr.push(passkeysArr[idx]);
				}
			}
			let newPasskeys=newPasskeysArr.join(',');
			commands.execute(":set passkeys="+newPasskeys);
		}
	}
}

function onUnload() {
	setPasskeys(false);
}
    
var Actions = new Object();
Actions['briefview'] = {
	description: 'View a Brief folder/feed',
	mapping: {
		keys: ['bv'],
		openExMode: true},
/*	noPromptMapping: {
		keys: ['bv'],
		openExMode: false}, */
	defaultArgument: 'All items',
	argName: 'feed',
	extraDescription: function() {
		let exDesc=['.  ',['oa',{},this.argName],' is the name of a Brief feed',
			'or feed folder.'];
		exDesc=exDesc.concat(defaultArgDescription(this.argName, this.defaultArgument));
		return exDesc},
	
	command: function(args) {
		var title;
		if (args.length==1) {
			title = args[0];
		} else {
			title='All items';
		}
		var id;
		
		let parentList;
		if (title in sidebarBuiltins) {
			id=sidebarBuiltins[title];
			parentList=window.content.document.getElementById('view-list');
		} else {
			var matches=window.content.document.getElementsByAttribute('title',title);
			if (matches.length==0) {
				dactyl.echoerr('No feed or folder found with that title.');
				return
			}
			// Just use the first match -- no support for duplicate titles
			id=matches[0].getAttribute('id');
			parentList=window.content.document.getElementById('feed-list');
		}
		
		parentList.selectedItem=window.content.document.getElementById(id);
	},
	options: {
		literal: 0,
		argCount: '?',
		completer: function(context,args) {
			context.completions=sidebarCompletions('feed,folder,builtin')}
	}
};

Actions['briefmark'] = {
	description: 'Mark an item(s) read/unread',
	mapping: {
		keys: ['bM'],
		openExMode: true},
	noPromptMapping: {
		keys: ['bm'],
		openExMode: false},
	defaultArgument: 'single',
	argName: 'group',
	extraDescription: function() {
		let exDesc=['.  ',['oa',{},this.argName],' is ',
			['str',{},'single'],' (single item), ',['str',{},'view'],
			' (all items in the current feed view), or ',['str',{},'starred'],
			' (all visible items).'];
		exDesc=exDesc.concat(defaultArgDescription(this.argName, this.defaultArgument));
		return exDesc},
	
	command: function(args) {
		var mode;
		if (args.length==1) {
			mode=args[0];
		} else {
			mode='single';
		}
		
		switch (mode) {
			case 'single':
				Brief.doCommand('toggleSelectedEntryRead');
				break
			case 'view':
				Brief.doCommand('markViewRead');
				break
			case 'visible':
				Brief.doCommand('markVisibleEntriesRead');
				break
		}
	},
	options: {
		argCount: '?',
		completer: function(context,args) {
			context.completions= [['single', 'Toggle single item read/unread'],
				['view', 'Mark current view read'],
				['visible', 'Mark visible items read']];
			}
	}
};

Actions['briefreveal'] = {
	description: 'Reveal all/unread/starred items',
	mapping: {
		keys: ['br'],
		openExMode: true},
/*	noPromptMapping: {
		keys: ['br'],
		openExMode: false}, */
	defaultArgument: 'all',
	argName: 'filter',
	extraDescription: function() {
		let exDesc=['.  ',['oa',{},this.argName],' is ',
			['str',{},'all'],', ',['str',{},'unread'],', or ',['str',{},'starred'],'.'];
		exDesc=exDesc.concat(defaultArgDescription(this.argName, this.defaultArgument));
		return exDesc},
	
	command: function(args) {
		var mode;
		if (args.length==1) {
			mode=args[0];
		} else {
			mode='all';
		}
		
		switch (mode) {
			case 'all':
				Brief.doCommand('showAllEntries');
				break
			case 'unread':
				Brief.doCommand('showUnreadEntries');
				break
			case 'starred':
				Brief.doCommand('showStarredEntries');
				break
		}
		window.content.location.reload();
	},
	options: {
		literal: 0,
		argCount: '?',
		completer: function(context, args) {
			context.completions= [['all', 'All items'],
							      ['unread', 'Unread items'],
							      ['starred', 'Starred items']];
		}
	}
};

Actions['briefheadlines'] = {
	description: 'Toggle headlines mode',
	mapping: {
		keys: ['bh'],
		openExMode: false},
	
	command: function(args) {
		Brief.doCommand('toggleHeadlinesView');
	},
	options: {
		argCount: 0
	}
};

Actions['briefdelete'] = {
	description: 'Delete selected entry (or restore if in Trash)',
	mapping: {
		keys: ['bd'],
		openExMode: false},
	
	command: function(args) {
		Brief.doCommand('deleteOrRestoreSelectedEntry');
	},
	options: {
		argCount: 0
	}
};

Actions['briefbookmark'] = {
	description: 'Bookmark/unbookmark selected entry',
	mapping: {
		keys: ['bb'],
		openExMode: false},
	
	command: function(args) {
		Brief.doCommand('toggleSelectedEntryStarred');
	},
	options: {
		argCount: 0
	}
};

Actions['brieffind'] = {
	description: 'Focus/clear search bar',
	mapping: {
		keys: ['bf'],
		openExMode: true},
	defaultArgument: 'focus',
	argName: 'action',
	extraDescription: function() {
		let exDesc=['.  ',['oa',{},this.argName],' is either',
			['str',{},'clear'],' or ',['str',{},'focus'],'.'];
		exDesc=exDesc.concat(defaultArgDescription(this.argName, this.defaultArgument));
		return exDesc},
	
	command: function(args) {
		var mode;
		if (args.length==1) {
			mode=args[0];
		} else {
			mode='focus';
		}
		
		var searchbar=window.content.document.getElementById('searchbar');
		
		switch (mode) {
			case 'focus':
				Brief.doCommand('focusSearchbar')
				break
			case 'clear':
				searchbar.reset();
				searchbar.blur();
				window.content.location.reload();
				break
		}
	},
	options: {
		literal: 0,
		argCount: '?',
		completer: function(context, args) {
			context.completions=[['focus', 'Focus search bar'],
				['clear', 'Clear search bar']];
		}
	}
};

Actions['briefexpand'] = {
	description: 'Expand/collapse item in headlines mode',
	mapping: {
		keys: ['be'],
		openExMode: false},
	
	command: function(args) {
		Brief.doCommand('toggleSelectedEntryCollapsed')
	},
	options: {
		argCount: 0
	}
};

Actions['briefsidebar'] = {
	description: 'Toggle sidebar',
	mapping: {
		keys: ['bs'],
		openExMode: false},
	
	command: function(args) {
		var sidebar=window.content.document.getElementById('sidebar');
		if (sidebar.hidden) {
			Brief.doCommand('revealSidebar');
		} else {
			Brief.doCommand('hideSidebar');
		}
	},
	options: {
		argCount: 0
	}
};

Actions['briefupdate'] = {
	description: 'Update a Brief folder/feed',
	mapping: {
		keys: ['bu'],
		openExMode: true},
/*	noPromptMapping: {
		keys: ['bu'],
		openExMode: false}, */
	defaultArgument: 'All items',
	argName: 'feed',
	extraDescription: function() {
		let exDesc=['.  ',['oa',{},this.argName],
			' is the name of any feed or folder.'];
		exDesc=exDesc.concat(defaultArgDescription(this.argName, this.defaultArgument));
		return exDesc},
	
	command: function(args) {
		var title;
		if (args.length==1) {
			title = args[0];
		} else {
			title='All items';
		}
		
		if (title=='current') {
			var viewlist=window.content.document.getElementById('view-list');
			var selection=viewlist.selectedItem;
			if (selection.id=='all-items-folder') {
				title='All items';
			} else {
				if (['unread-folder','starred-folder','trash-folder'].
						indexOf(selection.id)!=-1) {
					dactyl.echoerr("Can't update current selection.");
					return
				}
			}
		}
		
		switch (title) {
			case 'All items':
				Brief.doCommand('updateAllFeeds');
				break
			case 'stop':
				Brief.doCommand('stopUpdating');
				break
			default:
				var matches=window.content.document.getElementsByAttribute('title',title);
				if (matches.length==0) {
					dactyl.echoerr('No feed or folder found with that title.');
					return
				}
				
				Components.utils.import('resource://brief/Storage.jsm', localNS);
				Components.utils.import('resource://brief/FeedUpdateService.jsm');
				
				// Just use the first match -- no support for duplicate titles
				var id=matches[0].getAttribute('id');
				var elem=window.content.document.getElementById(id);
				if (elem.tagName=='richtreeitem') {
					FeedUpdateService.updateFeeds([localNS.Storage.getFeed(id)]);
				} else if (elem.tagName=='richtreefolder') {
					let items = elem.getElementsByTagName('richtreeitem');
					let feeds = [];
					for (let i = 0; i < items.length; i++) {
						feeds.push(localNS.Storage.getFeed(items[i].id));
					}
					FeedUpdateService.updateFeeds(feeds);
				}
		}
	},
	options: {
		literal: 0,
		argCount: '?',
		completer: function(context, args) {
			var completions=sidebarCompletions('feed,folder');
			completions.unshift(['current', 'Current item'],['All items','All items'],
				['stop','Stop updating feeds']);
			context.completions=completions;
		}
	}
};

Actions['brieftoggle'] = {
	description: 'Toggle feed folder open/closed',
	mapping: {
		keys: ['bt'],
		openExMode: true},
	defaultArgument: 'current',
	argName: 'folder',
	extraDescription: function() {
		let exDesc=['.  ',['oa',{},this.argName],' is the name of any feed folder.  '];
		exDesc=exDesc.concat(defaultArgDescription(this.argName, this.defaultArgument)); 
		return exDesc},
	
	command: function(args) {
		var title;
		if (args.length==1) {
			title = args[0];
		} else {
			title='current';
		}
	
		var folder;
		if (title=='current') {
			var viewlist=window.content.document.getElementById('view-list');
			var folder=viewlist.selectedItem;
			if (folder.tagName!='richtreefolder') {
				dactyl.echoerr('Current selection is not a feed folder.');
				return
			}
		} else {
			var matches=window.content.document.getElementsByAttribute('title',title);
			if (matches.length==0) {
				dactyl.echoerr('No folder found with that title.');
				return
			}
			// Just use the first match -- no support for duplicate titles
			folder=window.content.document.getElementById(matches[0].getAttribute('id'));
		}
		
		folder.toggleOpen();
	},
	options: {
		literal: 0,
		argCount: '?',
		completer: function(context,args) {
			var completions=sidebarCompletions('folder');
			completions.unshift(['current','Currently selected feed folder']);
			context.completions=completions;
		}
	}
};

var sidebarBuiltins = new Object();
sidebarBuiltins['All items'] = 'all-items-folder';
sidebarBuiltins['Unread'] = 'unread-folder';
sidebarBuiltins['Starred'] = 'starred-folder';
sidebarBuiltins['Trash'] = 'trash-folder';
    
function sidebarCompletions(targets) {
	var completions=[];
	
	targets=targets.split(',');
	if (targets.indexOf('builtin')!=-1) {
		for (var title in sidebarBuiltins) {
			completions.push([title, 'View']);
		}
	}
	
	if (targets.indexOf('folder')!=-1) {
		var folders=window.content.document.getElementsByClassName('feed-folder');
		for (var idx=0;idx<folders.length;idx++) {
			completions.push([folders[idx].getAttribute('title'), 'Folder']);
		}
	}
	
	if (targets.indexOf('feed')!=-1) {
		var folders=window.content.document.getElementsByClassName('feed-treeitem');
		for (var idx=0;idx<folders.length;idx++) {
			completions.push([folders[idx].getAttribute('title'), 'Feed']);
		}
	}
	
	return completions
}
    	
function addMapping(action, mapKind) {
	let command;
	let actionStr=action; //Needed for scoping/evaluation reasons
	if (Actions[action][mapKind].openExMode) {
		command=(function(args) {
			CommandExMode().open(actionStr+" ")
		});
	} else {
		command=(function(args) {
			(Actions[actionStr].command(args));
		});
	}
	
	group.mappings.add([modes.NORMAL], Actions[action][mapKind].keys, 
		Actions[action].description,
		(command),
		{}
	);
}

function defaultArgDescription(argName, defaultStr) {
	return ['  If ',['oa',{},argName],' is omitted, then the default value of ',
			['str',{},defaultStr],' is used.']
}

INFO.push(["item", {},
        ["tags", {}, ':briefopen'],
        ["spec", {}, ':briefopen'],
        ["description", { short: "true" },
            ["p", {}, 'Open/focus Brief.']]]);
            
INFO.push(['item', {},
	['tags',{},'brief-load-passkeys'],
	['spec',{},'brief-load-passkeys'],
	['type',{},'string'],
	['default',{},'true'],
	['description',{},
		['p',{},'If ',['str',{},'true'],', the plugin sets the following passkeys ',
		"for Brief's url: ",['str',{},defaultPasskeys],'. Many other keyboard ',
		"shortcuts are available in Brief (see Brief's preferences), but they conflict ",
		'with common ',
		'Pentadactyl mappings.  Most of their functionality is reproduced by ',
		'the commands provided by this plugin.'],
		['p',{},'The passkeys set by the plugin perform the following actions:'],
		['dl',{},
			['dt',{},'j'],['dd',{},'Select the next item'],
			['dt',{},'k'],['dd',{},'Select the previous item'],
			['dt',{},'h'],['dd',{},'Expand/collapse current item in headlines mode'],
			['dt',{},'<Enter>'],['dd',{},'Open the current item']
		]]]);

for (let action in Actions) {
	group.commands.add([action],Actions[action].description,
		Actions[action].command, Actions[action].options,true);

	for (let mapKind in {mapping: null, noPromptMapping: null}) {
		if (mapKind in Actions[action]) {
			addMapping(action, mapKind);
		}
	}
	
	let tagStr=":"+action;
	if ('mapping' in Actions[action]) {
		tagStr+=' '+Actions[action].mapping.keys.join(' ');
	}
	let specVal;
	if ('argName' in Actions[action]) {
		specVal=['spec',{},":"+action+' ',['oa',{},Actions[action].argName]];
	} else {
		specVal=['spec',{},":"+action];
	}
	let description=["p", {}, Actions[action].description];
	if ('extraDescription' in Actions[action]) {
		description=description.concat(Actions[action].extraDescription());
	}
	INFO.push(["item", {},
        ["tags", {}, tagStr],
        specVal,
        ["description", {},
            description]]);
            
    if ('noPromptMapping' in Actions[action]) {
    	tagStr=Actions[action].noPromptMapping.keys.join(' ');
    	INFO.push(["item", {},
			["tags", {}, tagStr],
			["spec", {}, tagStr],
			["description", { short: "true" },
				["p", {}, 'Excecute ',
					['ex',{},':'+action],' without opening the command prompt.']]]);
    }
}